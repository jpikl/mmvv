use crate::command_test;

command_test!("x", {
    empty_none: [ cmd "" assert "" => "" ],
    empty_many: [ cmd "" assert "a\nbc" => "\n\n" ],
    constant_none: [ cmd "xyz" assert "" => "" ],
    constant_many: [ cmd "xyz" assert "a\nbc" => "xyz\nxyz\n" ],
    empty_expr_none: [ cmd "{}" assert "" => "" ],
    empty_expr_many: [ cmd "{}" assert "a\nbc" => "a\nbc\n" ],
    simple_none: [ cmd "x_{}_y_{}_z" assert "" => "" ],
    simple_many: [ cmd "x_{}_y_{}_z" assert "a\nbc" => "x_a_y_a_z\nx_bc_y_bc_z\n" ],
    escaped_many: [ cmd "x_\\{\\}_y" assert "a\nbc" => "x_{}_y\nx_{}_y\n" ],
    escaped_alt_many: [ cmd "-e%" "x_%{%}_y" assert "a\nbc" => "x_{}_y\nx_{}_y\n" ],
    internal_cmd_none: [ cmd "x_{trim -s}_y" assert "" => "" ],
    internal_cmd_many: [ cmd "x_{trim -s}_y" assert " a \n  bc  " => "x_a _y\nx_bc  _y\n" ],
    internal_cmd_wrapped: [ cmd "x_{rew trim -s}_y" assert " a \n  bc  " => "x_a _y\nx_bc  _y\n" ],
    external_cmd_none: [ cmd "x_{tr -d 'b'}_y" assert "" => "" ],
    external_cmd_many: [ cmd "x_{tr -d 'b'}_y" assert "a\nbc" => "x_a_y\nx_c_y\n" ],
    pipeline_none: [ cmd "x_{trim -s | tr -d 'b'}_y" assert "" => "" ],
    pipeline_many: [ cmd "x_{trim -s | tr -d 'b'}_y" assert " a \n  bc  " => "x_a _y\nx_c  _y\n" ],
    complex_none: [ cmd "x_{}_{trim -s}_{tr -d 'b'}_{trim -s | tr -d 'b'}_y" assert "" => "" ],
    complex_many: [ cmd "x_{}_{trim -s}_{tr -d 'b'}_{trim -s | tr -d 'b'}_y" assert " a \n  bc  " => "x_ a _a _ a _a _y\nx_  bc  _bc  _  c  _c  _y\n" ],
    line_buf_none: [ cmd "--buf-mode=line" "x_{}_{trim -s}_{tr -d 'b'}_{trim -s | tr -d 'b'}_y" assert "" => "" ],
    line_buf_many: [ cmd "--buf-mode=line" "x_{}_{trim -s}_{tr -d 'b'}_{trim -s | tr -d 'b'}_y" assert " a \n  bc  " => "x_ a _a _ a _a _y\nx_  bc  _bc  _  c  _c  _y\n" ],
    records_none: [ cmd "-0" "x_{}_{trim -s}_{tr -d 'b'}_{trim -s | tr -d 'b'}_y" assert "" => "" ],
    records_many: [ cmd "-0" "x_{}_{trim -s}_{tr -d 'b'}_{trim -s | tr -d 'b'}_y" assert " a \0  bc  " => "x_ a _a _ a _a _y\0x_  bc  _bc  _  c  _c  _y\0" ],
    multipattern: [ cmd "x" "{}" "{trim}" assert "a\n bc " => "x a a\nx  bc  bc\n" ],
    shell_none: [ cmd "x_{# sed -E 's/^ +//' | tr -d 'b'}_y" assert "" => "" ],
    shell_many: [ cmd "x_{# sed -E 's/^ +//' | tr -d 'b'}_y" assert " a \n  bc  " => "x_a _y\nx_c  _y\n" ],
    shell_redirect: [ cmd "x_{# sed -E 's/^ +//' | tr -d 'b' > target/.dummy_output}_y" assert " a \n  bc  " => "" ],
    generator: [ cmd "x_{seq 1..2}_y" assert "" => "x_1_y\nx_2_y\n" ],
    cat_and_generator_none: [ cmd "x_{}_{seq 1..2}_y" assert "" => "" ],
    cat_and_generator_less: [ cmd "x_{}_{seq 1..2}_y" assert "a" => "x_a_1_y\n" ],
    cat_and_generator_eq: [ cmd "x_{}_{seq 1..2}_y" assert "a\nbc" => "x_a_1_y\nx_bc_2_y\n" ],
    cat_and_generator_more: [ cmd "x_{}_{seq 1..2}_y" assert "a\nbc\ndef" => "x_a_1_y\nx_bc_2_y\n" ],
    // Should not get stuck by pipeline command not reading its stdin
    cat_and_generator_many: [ sh "seq 1 100000 | %cmd% 'x_{}_{seq 1..100000}_y' | wc -l" assert "" => "100000\n" ],
    shell_and_generator_many: [ sh "seq 1 100000 | %cmd% 'x_{}_{:# seq 1 100000}_y' | wc -l" assert "" => "100000\n" ],
});
